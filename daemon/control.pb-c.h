/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: control.proto */

#ifndef PROTOBUF_C_control_2eproto__INCLUDED
#define PROTOBUF_C_control_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1000000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1002001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif

#include "guestos.pb-c.h"
#include "container.pb-c.h"
#include "common/logf.pb-c.h"

typedef struct _ContainerStartParams ContainerStartParams;
typedef struct _AssignInterfaceParams AssignInterfaceParams;
typedef struct _ControllerToDaemon ControllerToDaemon;
typedef struct _DaemonToController DaemonToController;
typedef struct _DaemonToConsole DaemonToConsole;
typedef struct _ConsoleToDaemon ConsoleToDaemon;


/* --- enums --- */

typedef enum _ControllerToDaemon__Command {
  /*
   * Responds with [guestos_configs] which includes a list of all GuestOS configs
   * installed on the device.
   */
  /*
   * -> [guestos_configs]
   */
  CONTROLLER_TO_DAEMON__COMMAND__LIST_GUESTOS_CONFIGS = 1,
  /*
   * Responds with [container_uuid] with the UUIDs of all containers
   * available on the device.
   */
  /*
   * -> [container_uuid]
   */
  CONTROLLER_TO_DAEMON__COMMAND__LIST_CONTAINERS = 2,
  /*
   * Responds [container_status] with the ContainerStatus
   * for each specified container in [container_uuid],
   * or for all containers if [container_uuid] is empty.
   */
  /*
   * [container_uuid] -> [container_status]
   */
  CONTROLLER_TO_DAEMON__COMMAND__GET_CONTAINER_STATUS = 3,
  /*
   * Responds [container_config] with the ContainerStatus
   * for each specified container in [container_uuid],
   * or for all containers if [container_uuid] is empty.
   * Also fills [container_uuids] with the corresponding container UUIDs.
   */
  /*
   * [container_uuid] -> [container_config]
   */
  CONTROLLER_TO_DAEMON__COMMAND__GET_CONTAINER_CONFIG = 4,
  /*
   *Returns /proc/last_kmsg and /dev/log/main (line by line).
   *This is a debugging feature!
   */
  CONTROLLER_TO_DAEMON__COMMAND__GET_LAST_LOG = 5,
  /*
   * Returns a namespace PID for the given container UUID
   */
  CONTROLLER_TO_DAEMON__COMMAND__GET_CONTAINER_PID = 6,
  /*
   * Starts or stops observing the status.
   * TODO not implemented yet
   */
  CONTROLLER_TO_DAEMON__COMMAND__OBSERVE_STATUS_START = 10,
  CONTROLLER_TO_DAEMON__COMMAND__OBSERVE_STATUS_STOP = 11,
  /*
   * Starts or stops observing log messages.
   */
  CONTROLLER_TO_DAEMON__COMMAND__OBSERVE_LOG_START = 14,
  CONTROLLER_TO_DAEMON__COMMAND__OBSERVE_LOG_STOP = 15,
  /*
   * Push new GuestOS config. Needs [guestos_config_*].
   * Images will be updated later.
   */
  CONTROLLER_TO_DAEMON__COMMAND__PUSH_GUESTOS_CONFIG = 20,
  /*
   * Reloads containers from config files, e.g. if a new container should be created
   */
  CONTROLLER_TO_DAEMON__COMMAND__RELOAD_CONTAINERS = 21,
  /*
   * Wipes the entire device (i.e. all containers)
   * TODO: Only wipes containers, not e.g. GuestOSes and device.conf.
   */
  CONTROLLER_TO_DAEMON__COMMAND__WIPE_DEVICE = 30,
  /*
   * Starts a container. Also needs [start_params].
   */
  CONTROLLER_TO_DAEMON__COMMAND__CONTAINER_START = 101,
  /*
   * Stops a container.
   */
  CONTROLLER_TO_DAEMON__COMMAND__CONTAINER_STOP = 102,
  /*
   * Switches to a container.
   */
  CONTROLLER_TO_DAEMON__COMMAND__CONTAINER_SWITCH = 103,
  /*
   * Freezes a container.
   */
  CONTROLLER_TO_DAEMON__COMMAND__CONTAINER_FREEZE = 104,
  /*
   *Unfreezes a container.
   */
  CONTROLLER_TO_DAEMON__COMMAND__CONTAINER_UNFREEZE = 105,
  /*
   * Wipes a container.
   */
  CONTROLLER_TO_DAEMON__COMMAND__CONTAINER_WIPE = 106,
  /*
   * TODO
   */
  CONTROLLER_TO_DAEMON__COMMAND__CONTAINER_SNAPSHOT = 107,
  CONTROLLER_TO_DAEMON__COMMAND__CONTAINER_ALLOWAUDIO = 108,
  CONTROLLER_TO_DAEMON__COMMAND__CONTAINER_DENYAUDIO = 109,
  /*
   * Assigns a network interface to a container. Also needs [assign_iface_params]
   */
  CONTROLLER_TO_DAEMON__COMMAND__CONTAINER_ASSIGNIFACE = 110,
  /*
   * Unassigns a network interface from a container. Also needs [assign_iface_params]
   */
  CONTROLLER_TO_DAEMON__COMMAND__CONTAINER_UNASSIGNIFACE = 111,
  /*
   * List network interfaces assigned to a container
   */
  CONTROLLER_TO_DAEMON__COMMAND__CONTAINER_LIST_IFACES = 112,
  /*
   * Execute command inside container
   */
  CONTROLLER_TO_DAEMON__COMMAND__CONTAINER_EXEC_CMD = 113,
  /*
   *Send input to exec'ed porgram
   */
  CONTROLLER_TO_DAEMON__COMMAND__CONTAINER_EXEC_INPUT = 114
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(CONTROLLER_TO_DAEMON__COMMAND)
} ControllerToDaemon__Command;
typedef enum _DaemonToController__Code {
  /*
   * -> [guestos_config]
   */
  DAEMON_TO_CONTROLLER__CODE__GUESTOS_CONFIGS_LIST = 1,
  /*
   * -> [container_uuid]
   */
  DAEMON_TO_CONTROLLER__CODE__CONTAINERS_LIST = 2,
  /*
   * -> [container_status]
   */
  DAEMON_TO_CONTROLLER__CODE__CONTAINER_STATUS = 3,
  /*
   * -> [container_config], [container_uuids]
   */
  DAEMON_TO_CONTROLLER__CODE__CONTAINER_CONFIG = 4,
  /*
   * -> [container_ifaces]
   */
  DAEMON_TO_CONTROLLER__CODE__CONTAINER_IFACES = 5,
  /*
   * -> [container_pid]
   */
  DAEMON_TO_CONTROLLER__CODE__CONTAINER_PID = 6,
  /*
   * -> [log_message]
   */
  DAEMON_TO_CONTROLLER__CODE__STATUS_CHANGED = 10,
  /*
   * -> [log_message]
   */
  DAEMON_TO_CONTROLLER__CODE__NOTIFICATION = 11,
  /*
   * -> [log_message]
   */
  DAEMON_TO_CONTROLLER__CODE__LOG_MESSAGE = 12,
  /*
   * -> [response]
   */
  DAEMON_TO_CONTROLLER__CODE__RESPONSE = 13,
  DAEMON_TO_CONTROLLER__CODE__EXEC_END = 14,
  DAEMON_TO_CONTROLLER__CODE__EXEC_OUTPUT = 15,
  /*
   * Log-on the device onto the backend (not applicable for cmdline tool).
   */
  /*
   * [device_uuid] ->
   */
  DAEMON_TO_CONTROLLER__CODE__LOGON_DEVICE = 200
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(DAEMON_TO_CONTROLLER__CODE)
} DaemonToController__Code;
typedef enum _DaemonToController__Response {
  DAEMON_TO_CONTROLLER__RESPONSE__CONTAINER_START_OK = 1,
  DAEMON_TO_CONTROLLER__RESPONSE__CONTAINER_START_LOCK_FAILED = 2,
  DAEMON_TO_CONTROLLER__RESPONSE__CONTAINER_START_UNLOCK_FAILED = 3,
  DAEMON_TO_CONTROLLER__RESPONSE__CONTAINER_START_PASSWD_WRONG = 4,
  DAEMON_TO_CONTROLLER__RESPONSE__CONTAINER_START_LOCKED_TILL_REBOOT = 5,
  DAEMON_TO_CONTROLLER__RESPONSE__CONTAINER_START_EEXIST = 6
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(DAEMON_TO_CONTROLLER__RESPONSE)
} DaemonToController__Response;
/*
 * Note: This message may change in the future!
 */
typedef enum _DaemonToConsole__Code {
  DAEMON_TO_CONSOLE__CODE__EXEC = 1,
  DAEMON_TO_CONSOLE__CODE__INPUT = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(DAEMON_TO_CONSOLE__CODE)
} DaemonToConsole__Code;
/*
 * Note: This message may change in the future!
 */
typedef enum _ConsoleToDaemon__Code {
  CONSOLE_TO_DAEMON__CODE__EXEC_FAILURE = 1,
  CONSOLE_TO_DAEMON__CODE__EXEC_SUCCESS = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(CONSOLE_TO_DAEMON__CODE)
} ConsoleToDaemon__Code;

/* --- messages --- */

struct  _ContainerStartParams
{
  ProtobufCMessage base;
  /*
   * Note: This message may change in the future!
   */
  char *key;
  protobuf_c_boolean has_no_switch;
  protobuf_c_boolean no_switch;
  protobuf_c_boolean has_setup;
  protobuf_c_boolean setup;
};
extern char container_start_params__key__default_value[];
#define CONTAINER_START_PARAMS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&container_start_params__descriptor) \
    , container_start_params__key__default_value, 0,0, 0,0 }


struct  _AssignInterfaceParams
{
  ProtobufCMessage base;
  char *iface_name;
  protobuf_c_boolean has_persistent;
  protobuf_c_boolean persistent;
};
#define ASSIGN_INTERFACE_PARAMS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&assign_interface_params__descriptor) \
    , NULL, 0,0 }


/*
 **
 * Control message sent to and processed by the cml-daemon on the device.
 */
struct  _ControllerToDaemon
{
  ProtobufCMessage base;
  ControllerToDaemon__Command command;
  /*
   * Container
   */
  /*
   * container UUID(s) for GET_CONTAINER_* and CONTAINER_*
   */
  size_t n_container_uuids;
  char **container_uuids;
  /*
   * start parameters for CONTAINER_START
   */
  ContainerStartParams *container_start_params;
  /*
   * parameter for CONTAINER_ASSIGNIFACE / CONTAINER_UNASSIGNIFACE
   */
  AssignInterfaceParams *assign_iface_params;
  char *exec_command;
  size_t n_exec_args;
  char **exec_args;
  char *exec_input;
  /*
   * Daemon
   */
  /*
   * new/updated GuestOS config for PUSH_GUESTOS_CONFIG
   */
  protobuf_c_boolean has_guestos_config_file;
  ProtobufCBinaryData guestos_config_file;
  /*
   * signature of the GuestOS config file
   */
  protobuf_c_boolean has_guestos_config_signature;
  ProtobufCBinaryData guestos_config_signature;
  /*
   * sw signing certificate to verify the signature on the config file
   */
  protobuf_c_boolean has_guestos_config_certificate;
  ProtobufCBinaryData guestos_config_certificate;
};
#define CONTROLLER_TO_DAEMON__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&controller_to_daemon__descriptor) \
    , 0, 0,NULL, NULL, NULL, NULL, 0,NULL, NULL, 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL} }


/*
 **
 * Control message sent from the cml-daemon on the device to the backend/cmdline tool/etc.
 * TODO: Maybe (but only maybe) use separate messages for the different endpoints.
 */
struct  _DaemonToController
{
  ProtobufCMessage base;
  DaemonToController__Code code;
  /*
   * GuestOS configs for LIST_GUESTOS_CONFIGS
   */
  size_t n_guestos_configs;
  GuestOSConfig **guestos_configs;
  /*
   * UUIDs for LIST_CONTAINERS
   */
  size_t n_container_uuids;
  char **container_uuids;
  /*
   * ContainerStatus(es) for GET_CONTAINER_STATUS
   */
  size_t n_container_status;
  ContainerStatus **container_status;
  /*
   * ContainerConfig(s) for GET_CONTAINER_CONFIG
   */
  size_t n_container_configs;
  ContainerConfig **container_configs;
  /*
   * Container network interface(s) for CONTAINER_LIST_IFACES
   */
  size_t n_container_ifaces;
  char **container_ifaces;
  /*
   * PID of the container's namespace
   */
  protobuf_c_boolean has_container_pid;
  uint32_t container_pid;
  /*
   * log message received because of OBSERVE_LOG_START
   */
  LogMessage *log_message;
  protobuf_c_boolean has_response;
  DaemonToController__Response response;
  /*
   * Device UUID for LOGON_DEVICE and LOG_MESSAGE
   */
  char *device_uuid;
  /*
   * Hardware name (e.g. "i9505", "hammerhead", ...) for LOGON_DEVICE
   */
  char *logon_hardware_name;
  /*
   * Hardware serial number for LOGON_DEVICE
   */
  char *logon_hardware_serial;
  /*
   * IMEI for LOGON_DEVICE
   */
  char *logon_imei;
  /*
   * MAC address for LOGON_DEVICE
   */
  char *logon_mac_address;
  /*
   * Phone number for LOGON_DEVICE
   */
  char *logon_phone_number;
  /*
   * 
   */
  char *exec_end_reason;
  /*
   * 
   */
  char *exec_output;
};
#define DAEMON_TO_CONTROLLER__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&daemon_to_controller__descriptor) \
    , 0, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,0, NULL, 0,0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }


struct  _DaemonToConsole
{
  ProtobufCMessage base;
  DaemonToConsole__Code code;
  char *command;
  size_t n_args;
  char **args;
  char *input;
};
extern char daemon_to_console__command__default_value[];
extern char daemon_to_console__input__default_value[];
#define DAEMON_TO_CONSOLE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&daemon_to_console__descriptor) \
    , 0, daemon_to_console__command__default_value, 0,NULL, daemon_to_console__input__default_value }


struct  _ConsoleToDaemon
{
  ProtobufCMessage base;
  ConsoleToDaemon__Code code;
  uint32_t pid;
};
#define CONSOLE_TO_DAEMON__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&console_to_daemon__descriptor) \
    , 0, 0u }


/* ContainerStartParams methods */
void   container_start_params__init
                     (ContainerStartParams         *message);
size_t container_start_params__get_packed_size
                     (const ContainerStartParams   *message);
size_t container_start_params__pack
                     (const ContainerStartParams   *message,
                      uint8_t             *out);
size_t container_start_params__pack_to_buffer
                     (const ContainerStartParams   *message,
                      ProtobufCBuffer     *buffer);
ContainerStartParams *
       container_start_params__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   container_start_params__free_unpacked
                     (ContainerStartParams *message,
                      ProtobufCAllocator *allocator);
/* AssignInterfaceParams methods */
void   assign_interface_params__init
                     (AssignInterfaceParams         *message);
size_t assign_interface_params__get_packed_size
                     (const AssignInterfaceParams   *message);
size_t assign_interface_params__pack
                     (const AssignInterfaceParams   *message,
                      uint8_t             *out);
size_t assign_interface_params__pack_to_buffer
                     (const AssignInterfaceParams   *message,
                      ProtobufCBuffer     *buffer);
AssignInterfaceParams *
       assign_interface_params__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   assign_interface_params__free_unpacked
                     (AssignInterfaceParams *message,
                      ProtobufCAllocator *allocator);
/* ControllerToDaemon methods */
void   controller_to_daemon__init
                     (ControllerToDaemon         *message);
size_t controller_to_daemon__get_packed_size
                     (const ControllerToDaemon   *message);
size_t controller_to_daemon__pack
                     (const ControllerToDaemon   *message,
                      uint8_t             *out);
size_t controller_to_daemon__pack_to_buffer
                     (const ControllerToDaemon   *message,
                      ProtobufCBuffer     *buffer);
ControllerToDaemon *
       controller_to_daemon__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   controller_to_daemon__free_unpacked
                     (ControllerToDaemon *message,
                      ProtobufCAllocator *allocator);
/* DaemonToController methods */
void   daemon_to_controller__init
                     (DaemonToController         *message);
size_t daemon_to_controller__get_packed_size
                     (const DaemonToController   *message);
size_t daemon_to_controller__pack
                     (const DaemonToController   *message,
                      uint8_t             *out);
size_t daemon_to_controller__pack_to_buffer
                     (const DaemonToController   *message,
                      ProtobufCBuffer     *buffer);
DaemonToController *
       daemon_to_controller__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   daemon_to_controller__free_unpacked
                     (DaemonToController *message,
                      ProtobufCAllocator *allocator);
/* DaemonToConsole methods */
void   daemon_to_console__init
                     (DaemonToConsole         *message);
size_t daemon_to_console__get_packed_size
                     (const DaemonToConsole   *message);
size_t daemon_to_console__pack
                     (const DaemonToConsole   *message,
                      uint8_t             *out);
size_t daemon_to_console__pack_to_buffer
                     (const DaemonToConsole   *message,
                      ProtobufCBuffer     *buffer);
DaemonToConsole *
       daemon_to_console__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   daemon_to_console__free_unpacked
                     (DaemonToConsole *message,
                      ProtobufCAllocator *allocator);
/* ConsoleToDaemon methods */
void   console_to_daemon__init
                     (ConsoleToDaemon         *message);
size_t console_to_daemon__get_packed_size
                     (const ConsoleToDaemon   *message);
size_t console_to_daemon__pack
                     (const ConsoleToDaemon   *message,
                      uint8_t             *out);
size_t console_to_daemon__pack_to_buffer
                     (const ConsoleToDaemon   *message,
                      ProtobufCBuffer     *buffer);
ConsoleToDaemon *
       console_to_daemon__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   console_to_daemon__free_unpacked
                     (ConsoleToDaemon *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*ContainerStartParams_Closure)
                 (const ContainerStartParams *message,
                  void *closure_data);
typedef void (*AssignInterfaceParams_Closure)
                 (const AssignInterfaceParams *message,
                  void *closure_data);
typedef void (*ControllerToDaemon_Closure)
                 (const ControllerToDaemon *message,
                  void *closure_data);
typedef void (*DaemonToController_Closure)
                 (const DaemonToController *message,
                  void *closure_data);
typedef void (*DaemonToConsole_Closure)
                 (const DaemonToConsole *message,
                  void *closure_data);
typedef void (*ConsoleToDaemon_Closure)
                 (const ConsoleToDaemon *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor container_start_params__descriptor;
extern const ProtobufCMessageDescriptor assign_interface_params__descriptor;
extern const ProtobufCMessageDescriptor controller_to_daemon__descriptor;
extern const ProtobufCEnumDescriptor    controller_to_daemon__command__descriptor;
extern const ProtobufCMessageDescriptor daemon_to_controller__descriptor;
extern const ProtobufCEnumDescriptor    daemon_to_controller__code__descriptor;
extern const ProtobufCEnumDescriptor    daemon_to_controller__response__descriptor;
extern const ProtobufCMessageDescriptor daemon_to_console__descriptor;
extern const ProtobufCEnumDescriptor    daemon_to_console__code__descriptor;
extern const ProtobufCMessageDescriptor console_to_daemon__descriptor;
extern const ProtobufCEnumDescriptor    console_to_daemon__code__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_control_2eproto__INCLUDED */
